;;; Simple BFS on a very small toy graph

.row_index
0, 2, 4, 8, 9, 10

.col_index
1, 2, 0, 2, 0, 1, 3, 4, 2, 2

.values
1, 1, 1, 1, 1, 1, 1, 1, 1, 1

.code
MOVI Rptr, 0        ; Start with the first node
PUSH Rptr           ; Start the frontier

MOVI Rtmp, 1        ; Mark the first node as visited
STR Rtmp, Rptr

MOVI Rptr, 65535    ; Start of BFS result (works backwards)

FSWAP               ; Swap the frontiers

loop:
    FEMPTY
    BZ next_level
    POP Rnode       ; Get next node
    STR Rnode, Rptr
    SUBI Rptr, Rptr, 1
    NITER

neighbor_loop:
    HASN
    BZ loop
    NNEXT            ; Get neighbor

    ; Check if visited
    LDR Rtmp, Rnbr  ; visited[neighbor]
    CMP Rtmp, Rzero
    BNZ neighbor_loop

    ; If not visited, mark and push
    MOVI Rtmp, 1    ; Need to store a 1 at visited[neighbor]
    STR Rtmp, Rnbr  ; Store the 1 at visited[neighbor]

    PUSH Rnbr       ; Add to frontier
    JMP neighbor_loop

next_level:
    ; Swap the Queues and check if the next queue is also empty
    FSWAP
    FEMPTY
    BZ done
    JMP loop    ; If the other queue is not empty, jump back to the main loop

done:
    HALT