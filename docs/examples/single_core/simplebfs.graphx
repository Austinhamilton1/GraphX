;;; Simple BFS on a very small toy graph

.code
MOVI Rtmp1, 0        ; Start with the first node
PUSH Rtmp1           ; Start the frontier

MOVI Rtmp2, 1        ; Mark the first node as visited
STR Rtmp2, Rtmp1

MOVI Rtmp1, 65535    ; Start of BFS result (works backwards)

FSWAP               ; Swap the frontiers

loop:
    FEMPTY
    BZ next_level
    POP Rnode       ; Get next node
    STR Rnode, Rtmp1
    SUBI Rtmp1, Rtmp1, 1
    NITER 0

neighbor_loop:
    NNEXT 0         ; Get neighbor
    BZ loop

    ; Check if visited
    LDR Rtmp2, Rnbr  ; visited[neighbor]
    CMP Rtmp2, Rzero
    BNZ neighbor_loop

    ; If not visited, mark and push
    MOVI Rtmp2, 1    ; Need to store a 1 at visited[neighbor]
    STR Rtmp2, Rnbr  ; Store the 1 at visited[neighbor]

    PUSH Rnbr       ; Add to frontier
    JMP neighbor_loop

next_level:
    ; Swap the Queues and check if the next queue is also empty
    FSWAP
    FEMPTY
    BZ done
    JMP loop    ; If the other queue is not empty, jump back to the main loop

done:
    HALT

.row_index
0, 2, 4, 8, 9, 10

.col_index
1, 2, 0, 2, 0, 1, 3, 4, 2, 2

.values
1, 1, 1, 1, 1, 1, 1, 1, 1, 1