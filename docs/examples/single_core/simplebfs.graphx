;;; Simple BFS on a very small toy graph

.code
MOV Rtmp1, #0       ; Start with the first node
FPUSH Rtmp1          ; Start the frontier

MOV Rtmp2, #1       ; Mark the first node as visited
ST Rtmp2, Rtmp1

MOV Rtmp1, #65535   ;Start of BFS result (works backwards)

FSWAP               ; Swap the frontiers

loop:
    FEMPTY
    BZ next_level
    FPOP Rnode       ; Get next node
    ST Rnode, Rtmp1
    SUB Rtmp1, Rtmp1, #1
    NITER #0

neighbor_loop:
    NNEXT #0         ; Get neighbor
    BZ loop

    ; Check if visited
    LD Rtmp2, Rnbr  ; visited[neighbor]
    CMP Rtmp2, Rzero
    BNZ neighbor_loop

    ; If not visited, mark and push
    MOV Rtmp2, #1   ; Need to store a 1 at visited[neighbor]
    ST Rtmp2, Rnbr  ; Store the 1 at visited[neighbor]

    FPUSH Rnbr       ; Add to frontier
    JMP neighbor_loop

next_level:
    ; Swap the Queues and check if the next queue is also empty
    FSWAP
    FEMPTY
    BZ done
    JMP loop    ; If the other queue is not empty, jump back to the main loop

done:
    HALT

.row_index
0, 2, 4, 8, 9, 10

.col_index
1, 2, 0, 2, 0, 1, 3, 4, 2, 2

.values
1, 1, 1, 1, 1, 1, 1, 1, 1, 1